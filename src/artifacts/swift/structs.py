import asyncio
import dataclasses
from typing import Dict

@dataclasses.dataclass
class StepOutput:
    """
    The output of one decoding step
    """
    token_id: int
    request: "SwiftRequest"

class SwiftRequest:
    """
    A (queuing, processing, or finished) request in the system
    """   

    prompt_token_ids: list[int]     # Prompt token ids, generated by the tokenizer upon request arrival
    prompt_len: int     # len(prompt_token_ids)
    output_len: int     # Output length

    output_q: asyncio.Queue[StepOutput] # Queue initialized when the raw request enters the
                                        # engine, and to be set upon a new token being generated
                                        # Mainly for streaming the output back to the user
    finished_event: asyncio.Event       # Event to be set when the request is finished
                                        # Mainly for the non-streaming case

    request_id: int     # Request ID, within range [0, max_seqs_in_block_table).
                        # Generated before being prefilled, and used as the index
                        # into the block table
    output_token_ids: list[int]     # Output token ids

    def __init__(self, raw_request: Dict[str, any]):
        # A request is __init__-ed when entering `untokenized_raw_requests`, and
        # its `prompt_token_ids` and `prompt_len` will be set upon tokenization
        self.prompt_token_ids = []
        self.prompt_len = 0
        self.output_len = raw_request["output_len"]
        self.output_q = asyncio.Queue()
        self.finished_event = asyncio.Event()
        self.request_id = -1
        self.output_token_ids = []
    
    def is_finished(self) -> bool:
        return len(self.output_token_ids) >= self.output_len
    
    def get_cur_output_len(self) -> int:
        return len(self.output_token_ids)

    def is_prefill_stage(self) -> bool:
        return not self.output_token_ids


class RequestIdManager:
    """
    A class that maintains available request ids
    """

    def __init__(self, max_id: int):
        # Id should be in range [0, max_id)
        self.max_id = max_id
        self.available_ids = list(range(max_id))
        self.available_ids.reverse()  # This reverse is not necessary. We have
        # this for more convinent debugging since
        # we always pop from the end and after
        # reversing, smaller ids are popped first

    def get_id(self) -> int:
        if not self.available_ids:
            raise RuntimeError(
                "No more available request ids. Please try to increase `max_seqs_in_block_table`"
            )
        return self.available_ids.pop()

    def free_id(self, req_id: int):
        self.available_ids.append(req_id)

    def free_ids(self, req_ids: list[int]):
        self.available_ids.extend(req_ids)
